---
alwaysApply: true
---

# Code Style and Comments

## No Assert Statements in Production Code

- **Never use `assert` statements in production code** (test code is allowed to use assert)
- Replace `assert` statements with proper error handling using exceptions:
  - Use `ValueError` for invalid values
  - Use `TypeError` for type mismatches
  - Use `AttributeError` for missing attributes
  - Use custom exceptions from `audiometa.exceptions` when appropriate
- The pre-commit hook will fail if assert statements are found
- Example:
  ```python
  # ❌ Bad
  assert value is not None
  assert isinstance(value, str)

  # ✅ Good
  if value is None:
      raise ValueError("value cannot be None")
  if not isinstance(value, str):
      raise TypeError(f"expected str, got {type(value).__name__}")
  ```

## Avoid Unnecessary Comments

Do NOT add comments for functions, classes, or modules that are self-explanatory. The function name, class name, and parameters should clearly indicate what they do.

### ❌ Avoid these unnecessary comments:

```python
"""Test cases for artists metadata."""
class TestArtistsMetadata:
    """Test cases for artists metadata."""

def test_artists_metadata_mp3():
    """Test artists metadata for MP3 files."""

def test_forced_format_affects_delete_metadata_behavior():
    """Test that forced format affects delete_metadata behavior."""

def get_user_name():
    """This function returns the user's name."""
    return user.name

def calculate_total(price, tax):
    """This function calculates the total price."""
    return price + (price * tax)
```

### ✅ Good - No comments needed:

```python
class TestArtistsMetadata:
    def test_artists_metadata_mp3(self, sample_mp3_file: Path, temp_audio_file: Path):
        # Test implementation here

    def test_forced_format_affects_delete_metadata_behavior(self):
        # Test implementation here

def get_user_name():
    return user.name

def calculate_total(price, tax):
    return price + (price * tax)
```

### ✅ Only add comments when they provide value:

```python
def calculate_compound_interest(principal, rate, time):
    # Uses the formula: A = P(1 + r/n)^(nt) where n=12 for monthly compounding
    return principal * (1 + rate/12) ** (12 * time)

def process_audio_metadata(file_path):
    # Handles edge cases where ID3v2 tags may be corrupted
    # and falls back to ID3v1 if necessary
    try:
        return extract_id3v2_metadata(file_path)
    except CorruptedTagError:
        return extract_id3v1_metadata(file_path)
```

## When to Add Comments

Only add function, class, or module comments when:

1. The function/class implements complex business logic that isn't obvious
2. There are important edge cases or assumptions to document
3. The function/class has non-obvious side effects
4. The function/class uses algorithms or formulas that need explanation
5. There are performance considerations or limitations to note

## When NOT to Add Comments

Do NOT add comments for:

- Simple getter/setter functions
- Functions with descriptive names that clearly indicate their purpose
- Standard CRUD operations
- Functions that are self-documenting through their implementation
- Test functions with obvious names like `test_artists_metadata_mp3`
- Class docstrings that just repeat the class name
- Module docstrings that just describe what the module contains

## Docstring Format (When Docstrings ARE Needed)

When docstrings are needed (for public API, complex logic, etc.), use a **systematic Google-style format** for consistency:

```python
def public_api_function(param1: str, param2: int | None = None) -> dict[str, Any]:
    """Brief one-line description.

    More detailed explanation if needed. Can span multiple lines
    to explain complex behavior, edge cases, or important details.

    Args:
        param1: Description of param1
        param2: Description of param2. Defaults to None.

    Returns:
        Description of return value

    Raises:
        ValueError: When param1 is invalid
        FileNotFoundError: When file doesn't exist

    Examples:
        >>> result = public_api_function("test", 42)
        >>> print(result)
        {'key': 'value'}
    """
    # Implementation
```

### When to Add Docstrings

- Public API functions/classes (exported from `__init__.py`)
- Complex business logic that isn't obvious
- Functions with non-obvious side effects
- Important edge cases or assumptions

### When NOT to Add Docstrings

- Simple getter/setter functions
- Self-explanatory functions with descriptive names
- Test functions (unless testing complex scenarios)
- Internal helper functions that are obvious from context
