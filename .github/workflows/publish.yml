# Maintainer-only: PyPI Publishing workflow
# Contributors cannot modify this file. Changes to publishing infrastructure require maintainer approval.
# Publishing workflows handle sensitive secrets and can publish packages to PyPI.
name: Publish to PyPI

on:
  push:
    tags:
      - "v*" # Triggers on tags like v0.3.0, v1.0.0, etc.

jobs:
  publish:
    name: Build and Publish to PyPI
    runs-on: ubuntu-latest
    # Only allow publishing from main branch tags (prevents accidental publishes from feature branches)
    if: github.ref_type == 'tag' && startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history for tag verification

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"
          cache: "pip"

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Extract version from pyproject.toml
        id: extract_version
        run: |
          VERSION=$(grep -E '^version\s*=' pyproject.toml | sed -E 's/version\s*=\s*"([^"]+)"/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Verify tag matches version
        run: |
          TAG_VERSION="${GITHUB_REF#refs/tags/v}"  # Remove 'v' prefix from tag
          PROJECT_VERSION="${{ steps.extract_version.outputs.version }}"

          echo "Tag version: $TAG_VERSION"
          echo "Project version: $PROJECT_VERSION"

          if [ "$TAG_VERSION" != "$PROJECT_VERSION" ]; then
            echo "Error: Tag version ($TAG_VERSION) does not match pyproject.toml version ($PROJECT_VERSION)"
            echo "Tag format should be: v$PROJECT_VERSION (e.g., v0.3.0)"
            exit 1
          fi

          echo "Version verification passed ✓"

      - name: Verify tag is on main branch
        run: |
          TAG_COMMIT=$(git rev-parse ${{ github.ref }})
          echo "Tag points to commit: $TAG_COMMIT"

          # Check if tag commit exists on main branch
          git fetch origin main:main 2>/dev/null || true
          if ! git branch --contains "$TAG_COMMIT" | grep -q "main"; then
            echo "Error: Tag ${{ github.ref }} points to commit $TAG_COMMIT which is not on main branch"
            echo "This prevents publishing code that hasn't been merged to main."
            echo ""
            echo "To fix this:"
            echo "1. Ensure all commits are pushed to main: git push origin main"
            echo "2. Verify the tag points to a commit on main"
            echo "3. Re-push the tag if needed: git tag -d v${{ steps.extract_version.outputs.version }} && git tag v${{ steps.extract_version.outputs.version }} && git push origin v${{ steps.extract_version.outputs.version }}"
            exit 1
          fi

          echo "✓ Tag is on main branch"

      - name: Verify CI has passed for tag commit
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tagCommit = '${{ github.sha }}';
            const [owner, repo] = '${{ github.repository }}'.split('/');

            console.log(`Checking CI status for commit: ${tagCommit}`);

            // Get the latest workflow run for this commit
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              head_sha: tagCommit,
              per_page: 10
            });

            // Find the CI workflow run
            const ciRun = runs.workflow_runs.find(run => run.name === 'CI' && run.head_sha === tagCommit);

            if (!ciRun) {
              console.log('⚠️  Warning: No CI workflow run found for this commit.');
              console.log('This might mean CI hasn\'t run yet or the commit wasn\'t pushed to main.');
              console.log('Waiting 30 seconds for CI to potentially start...');
              await new Promise(resolve => setTimeout(resolve, 30000));

              // Check again
              const { data: runs2 } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                head_sha: tagCommit,
                per_page: 10
              });

              const ciRun2 = runs2.workflow_runs.find(run => run.name === 'CI' && run.head_sha === tagCommit);

              if (!ciRun2) {
                throw new Error(`No CI workflow run found for commit ${tagCommit}. Ensure CI has run and passed before publishing.`);
              }

              if (ciRun2.status !== 'completed' || ciRun2.conclusion !== 'success') {
                throw new Error(`CI workflow has not completed successfully. Status: ${ciRun2.status}, Conclusion: ${ciRun2.conclusion}. CI must pass before publishing.`);
              }

              console.log('✓ CI has passed for this commit');
              return;
            }

            if (ciRun.status !== 'completed') {
              throw new Error(`CI workflow is still running (status: ${ciRun.status}). Wait for CI to complete before publishing.`);
            }

            if (ciRun.conclusion !== 'success') {
              throw new Error(`CI workflow did not pass (conclusion: ${ciRun.conclusion}). CI must pass before publishing.`);
            }

            console.log('✓ CI has passed for this commit');

      - name: Build package
        run: |
          python -m build

      - name: Check package contents
        run: |
          echo "Source distribution contents:"
          tar -tzf dist/*.tar.gz | head -30
          echo ""
          echo "Wheel contents:"
          unzip -l dist/*.whl | head -30

      - name: Publish to TestPyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.TEST_PYPI_API_TOKEN }}
        run: |
          twine upload --repository-url https://test.pypi.org/legacy/ dist/*

      - name: Verify TestPyPI publication by installing
        run: |
          python -m pip install --upgrade pip
          pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ audiometa-python==${{ steps.extract_version.outputs.version }}
          python -c "import audiometa; print('Successfully installed from TestPyPI')"
          python -c "from audiometa import get_unified_metadata; print('Package imports and functions work correctly')"

      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          twine upload dist/*

      - name: Verify PyPI publication by installing
        run: |
          python -m pip install --upgrade pip
          pip install audiometa-python==${{ steps.extract_version.outputs.version }}
          python -c "import audiometa; print('Successfully installed from PyPI')"
          python -c "from audiometa import get_unified_metadata; print('Package imports and functions work correctly')"

      - name: Post-publish verification check
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          PACKAGE_NAME="audiometa-python"

          echo "Verifying package availability on PyPI..."
          echo "Waiting a few seconds for PyPI to propagate the package..."
          sleep 5

          # Retry logic: PyPI API might need a moment to update
          MAX_RETRIES=5
          RETRY_COUNT=0
          API_RESPONSE=""

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            API_RESPONSE=$(curl -s "https://pypi.org/pypi/${PACKAGE_NAME}/${VERSION}/json" 2>/dev/null || echo "")

            if [ -n "$API_RESPONSE" ] && [ "$API_RESPONSE" != "null" ] && [ "$API_RESPONSE" != "Not Found" ]; then
              break
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Package not yet available, retrying in 3 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
              sleep 3
            fi
          done

          if [ -z "$API_RESPONSE" ] || [ "$API_RESPONSE" = "null" ] || [ "$API_RESPONSE" = "Not Found" ]; then
            echo "Error: Package version ${VERSION} not found on PyPI after ${MAX_RETRIES} attempts"
            exit 1
          fi

          # Verify version matches
          API_VERSION=$(echo "$API_RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin)['info']['version'])" 2>/dev/null || echo "")

          if [ "$API_VERSION" != "$VERSION" ]; then
            echo "Error: Version mismatch. Expected ${VERSION}, got ${API_VERSION}"
            exit 1
          fi

          # Verify package name matches
          API_NAME=$(echo "$API_RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin)['info']['name'])" 2>/dev/null || echo "")

          if [ "$API_NAME" != "$PACKAGE_NAME" ]; then
            echo "Error: Package name mismatch. Expected ${PACKAGE_NAME}, got ${API_NAME}"
            exit 1
          fi

          echo "✓ Package verified on PyPI API"
          echo "✓ Version matches: ${VERSION}"
          echo "✓ Package name matches: ${PACKAGE_NAME}"
          echo ""
          echo "Package published successfully!"
          echo "View on PyPI: https://pypi.org/project/${PACKAGE_NAME}/${VERSION}/"
          echo ""
          echo "Install with: pip install ${PACKAGE_NAME}==${VERSION}"
