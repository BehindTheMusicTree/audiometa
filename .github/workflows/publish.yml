# Maintainer-only: PyPI Publishing workflow
# Contributors cannot modify this file. Changes to publishing infrastructure require maintainer approval.
# Publishing workflows handle sensitive secrets and can publish packages to PyPI.
name: Publish to PyPI

on:
  push:
    tags:
      - "v*" # Triggers on tags like v0.3.0, v1.0.0, etc.

jobs:
  publish:
    name: Build and Publish to PyPI
    runs-on: ubuntu-latest
    # Only allow publishing from main branch tags (prevents accidental publishes from feature branches)
    if: github.ref_type == 'tag' && startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history for tag verification

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"
          cache: "pip"

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Extract version from pyproject.toml
        id: extract_version
        run: |
          VERSION=$(grep -E '^version\s*=' pyproject.toml | sed -E 's/version\s*=\s*"([^"]+)"/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Verify tag matches version
        run: |
          TAG_VERSION="${GITHUB_REF#refs/tags/v}"  # Remove 'v' prefix from tag
          PROJECT_VERSION="${{ steps.extract_version.outputs.version }}"

          echo "Tag version: $TAG_VERSION"
          echo "Project version: $PROJECT_VERSION"

          if [ "$TAG_VERSION" != "$PROJECT_VERSION" ]; then
            echo "Error: Tag version ($TAG_VERSION) does not match pyproject.toml version ($PROJECT_VERSION)"
            echo "Tag format should be: v$PROJECT_VERSION (e.g., v0.3.0)"
            exit 1
          fi

          echo "Version verification passed ✓"

      - name: Build package
        run: |
          python -m build

      - name: Check package contents
        run: |
          echo "Source distribution contents:"
          tar -tzf dist/*.tar.gz | head -30
          echo ""
          echo "Wheel contents:"
          unzip -l dist/*.whl | head -30

      - name: Publish to TestPyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.TEST_PYPI_API_TOKEN }}
        run: |
          twine upload --repository-url https://test.pypi.org/legacy/ dist/*

      - name: Verify TestPyPI publication by installing
        run: |
          python -m pip install --upgrade pip
          pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ audiometa-python==${{ steps.extract_version.outputs.version }}
          python -c "import audiometa; print('Successfully installed from TestPyPI')"
          python -c "from audiometa import get_unified_metadata; print('Package imports and functions work correctly')"

      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          twine upload dist/*

      - name: Verify PyPI publication by installing
        run: |
          python -m pip install --upgrade pip
          pip install audiometa-python==${{ steps.extract_version.outputs.version }}
          python -c "import audiometa; print('Successfully installed from PyPI')"
          python -c "from audiometa import get_unified_metadata; print('Package imports and functions work correctly')"

      - name: Post-publish verification check
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          PACKAGE_NAME="audiometa-python"

          echo "Verifying package availability on PyPI..."
          echo "Waiting a few seconds for PyPI to propagate the package..."
          sleep 5

          # Retry logic: PyPI API might need a moment to update
          MAX_RETRIES=5
          RETRY_COUNT=0
          API_RESPONSE=""

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            API_RESPONSE=$(curl -s "https://pypi.org/pypi/${PACKAGE_NAME}/${VERSION}/json" 2>/dev/null || echo "")

            if [ -n "$API_RESPONSE" ] && [ "$API_RESPONSE" != "null" ] && [ "$API_RESPONSE" != "Not Found" ]; then
              break
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Package not yet available, retrying in 3 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
              sleep 3
            fi
          done

          if [ -z "$API_RESPONSE" ] || [ "$API_RESPONSE" = "null" ] || [ "$API_RESPONSE" = "Not Found" ]; then
            echo "Error: Package version ${VERSION} not found on PyPI after ${MAX_RETRIES} attempts"
            exit 1
          fi

          # Verify version matches
          API_VERSION=$(echo "$API_RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin)['info']['version'])" 2>/dev/null || echo "")

          if [ "$API_VERSION" != "$VERSION" ]; then
            echo "Error: Version mismatch. Expected ${VERSION}, got ${API_VERSION}"
            exit 1
          fi

          # Verify package name matches
          API_NAME=$(echo "$API_RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin)['info']['name'])" 2>/dev/null || echo "")

          if [ "$API_NAME" != "$PACKAGE_NAME" ]; then
            echo "Error: Package name mismatch. Expected ${PACKAGE_NAME}, got ${API_NAME}"
            exit 1
          fi

          echo "✓ Package verified on PyPI API"
          echo "✓ Version matches: ${VERSION}"
          echo "✓ Package name matches: ${PACKAGE_NAME}"
          echo ""
          echo "Package published successfully!"
          echo "View on PyPI: https://pypi.org/project/${PACKAGE_NAME}/${VERSION}/"
          echo ""
          echo "Install with: pip install ${PACKAGE_NAME}==${VERSION}"
