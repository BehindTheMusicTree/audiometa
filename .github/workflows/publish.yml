# Maintainer-only: PyPI Publishing workflow
# Contributors cannot modify this file. Changes to publishing infrastructure require maintainer approval.
# Publishing workflows handle sensitive secrets and can publish packages to PyPI.
name: Publish to PyPI

on:
  push:
    tags:
      - "v*" # Triggers on tags like v0.3.0, v1.0.0, etc.

jobs:
  publish:
    name: Build and Publish to PyPI
    runs-on: ubuntu-latest
    # Only allow publishing from main branch tags (prevents accidental publishes from feature branches)
    if: github.ref_type == 'tag' && startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history for tag verification

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"
          cache: "pip"

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Extract version from pyproject.toml
        id: extract_version
        run: |
          VERSION=$(grep -E '^version\s*=' pyproject.toml | sed -E 's/version\s*=\s*"([^"]+)"/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Verify tag matches version
        run: |
          TAG_VERSION="${GITHUB_REF#refs/tags/v}"  # Remove 'v' prefix from tag
          PROJECT_VERSION="${{ steps.extract_version.outputs.version }}"

          echo "Tag version: $TAG_VERSION"
          echo "Project version: $PROJECT_VERSION"

          if [ "$TAG_VERSION" != "$PROJECT_VERSION" ]; then
            echo "Error: Tag version ($TAG_VERSION) does not match pyproject.toml version ($PROJECT_VERSION)"
            echo "Tag format should be: v$PROJECT_VERSION (e.g., v0.3.0)"
            exit 1
          fi

          echo "Version verification passed ✓"

      - name: Verify tag is on main branch
        run: |
          TAG_COMMIT=$(git rev-parse ${{ github.ref }})
          echo "Tag points to commit: $TAG_COMMIT"

          # Check if tag commit exists on main branch
          git fetch origin main:main 2>/dev/null || true
          if ! git branch --contains "$TAG_COMMIT" | grep -q "main"; then
            echo "Error: Tag ${{ github.ref }} points to commit $TAG_COMMIT which is not on main branch"
            echo "This prevents publishing code that hasn't been merged to main."
            echo ""
            echo "To fix this:"
            echo "1. Ensure all commits are pushed to main: git push origin main"
            echo "2. Verify the tag points to a commit on main"
            echo "3. Re-push the tag if needed: git tag -d v${{ steps.extract_version.outputs.version }} && git tag v${{ steps.extract_version.outputs.version }} && git push origin v${{ steps.extract_version.outputs.version }}"
            exit 1
          fi

          echo "✓ Tag is on main branch"

      - name: Verify CI has passed for tag commit
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tagCommit = '${{ github.sha }}';
            const [owner, repo] = '${{ github.repository }}'.split('/');

            console.log(`Checking CI status for commit: ${tagCommit}`);

            // Polling configuration
            const POLL_INTERVAL_MS = 30000; // Check every 30 seconds
            const MAX_WAIT_MS = 30 * 60 * 1000; // Maximum wait time: 30 minutes
            const MAX_ATTEMPTS = Math.floor(MAX_WAIT_MS / POLL_INTERVAL_MS);

            // Function to find CI workflow run
            const findCIRun = async () => {
              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                head_sha: tagCommit,
                per_page: 10
              });
              return runs.workflow_runs.find(run => run.name === 'CI' && run.head_sha === tagCommit);
            };

            // Poll for CI workflow run
            let ciRun = await findCIRun();
            let attempts = 0;

            if (!ciRun) {
              console.log('⚠️  Warning: No CI workflow run found for this commit.');
              console.log('Waiting for CI workflow to start...');

              // Wait for CI to start
              while (!ciRun && attempts < MAX_ATTEMPTS) {
                attempts++;
                console.log(`Waiting for CI to start... (attempt ${attempts}/${MAX_ATTEMPTS})`);
                await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));
                ciRun = await findCIRun();
              }

              if (!ciRun) {
                throw new Error(`No CI workflow run found for commit ${tagCommit} after ${MAX_WAIT_MS / 1000 / 60} minutes. Ensure CI has run and passed before publishing.`);
              }
            }

            console.log(`Found CI workflow run: ${ciRun.id}, status: ${ciRun.status}, conclusion: ${ciRun.conclusion || 'pending'}`);

            // Poll for CI completion
            attempts = 0; // Reset counter for completion polling
            while (ciRun.status !== 'completed' && attempts < MAX_ATTEMPTS) {
              attempts++;
              const elapsedMinutes = Math.floor((attempts * POLL_INTERVAL_MS) / 1000 / 60);
              console.log(`CI workflow is still running (status: ${ciRun.status}). Waiting... (${elapsedMinutes} minutes elapsed)`);
              await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));

              // Refresh CI run status
              const { data: updatedRun } = await github.rest.actions.getWorkflowRun({
                owner,
                repo,
                run_id: ciRun.id
              });
              ciRun = updatedRun;
            }

            if (ciRun.status !== 'completed') {
              throw new Error(`CI workflow did not complete within ${MAX_WAIT_MS / 1000 / 60} minutes (status: ${ciRun.status}). Please check CI workflow manually.`);
            }

            if (ciRun.conclusion !== 'success') {
              throw new Error(`CI workflow did not pass (conclusion: ${ciRun.conclusion}). CI must pass before publishing.`);
            }

            console.log('✓ CI has passed for this commit');

      - name: Build package
        run: |
          python -m build

      - name: Check package contents
        run: |
          echo "Source distribution contents:"
          tar -tzf dist/*.tar.gz | head -30
          echo ""
          echo "Wheel contents:"
          unzip -l dist/*.whl | head -30

      - name: Publish to TestPyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.TEST_PYPI_API_TOKEN }}
        run: |
          twine upload --repository-url https://test.pypi.org/legacy/ dist/*

      - name: Verify TestPyPI publication by installing
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          echo "Waiting for TestPyPI to propagate package version ${VERSION}..."
          sleep 10

          # Retry logic: TestPyPI might need a moment to update
          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            python -m pip install --upgrade pip
            if pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ audiometa-python==${VERSION} 2>&1; then
              echo "✓ Successfully installed audiometa-python==${VERSION} from TestPyPI"
              python -c "import audiometa; print('Successfully installed from TestPyPI')"
              python -c "from audiometa import get_unified_metadata; print('Package imports and functions work correctly')"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Package not yet available on TestPyPI, retrying in 5 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 5
              else
                echo "Error: Could not install audiometa-python==${VERSION} from TestPyPI after ${MAX_RETRIES} attempts"
                exit 1
              fi
            fi
          done

      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          twine upload dist/*

      - name: Verify PyPI publication by installing
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          echo "Waiting for PyPI to propagate package version ${VERSION}..."
          sleep 10

          # Retry logic: PyPI might need a moment to update
          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            python -m pip install --upgrade pip
            if pip install audiometa-python==${VERSION} 2>&1; then
              echo "✓ Successfully installed audiometa-python==${VERSION} from PyPI"
              python -c "import audiometa; print('Successfully installed from PyPI')"
              python -c "from audiometa import get_unified_metadata; print('Package imports and functions work correctly')"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Package not yet available on PyPI, retrying in 5 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 5
              else
                echo "Error: Could not install audiometa-python==${VERSION} from PyPI after ${MAX_RETRIES} attempts"
                exit 1
              fi
            fi
          done

      - name: Post-publish verification check
        run: |
          VERSION="${{ steps.extract_version.outputs.version }}"
          PACKAGE_NAME="audiometa-python"

          echo "Verifying package availability on PyPI..."
          echo "Waiting a few seconds for PyPI to propagate the package..."
          sleep 5

          # Retry logic: PyPI API might need a moment to update
          MAX_RETRIES=5
          RETRY_COUNT=0
          API_RESPONSE=""

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            API_RESPONSE=$(curl -s "https://pypi.org/pypi/${PACKAGE_NAME}/${VERSION}/json" 2>/dev/null || echo "")

            if [ -n "$API_RESPONSE" ] && [ "$API_RESPONSE" != "null" ] && [ "$API_RESPONSE" != "Not Found" ]; then
              break
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Package not yet available, retrying in 3 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
              sleep 3
            fi
          done

          if [ -z "$API_RESPONSE" ] || [ "$API_RESPONSE" = "null" ] || [ "$API_RESPONSE" = "Not Found" ]; then
            echo "Error: Package version ${VERSION} not found on PyPI after ${MAX_RETRIES} attempts"
            exit 1
          fi

          # Verify version matches
          API_VERSION=$(echo "$API_RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin)['info']['version'])" 2>/dev/null || echo "")

          if [ "$API_VERSION" != "$VERSION" ]; then
            echo "Error: Version mismatch. Expected ${VERSION}, got ${API_VERSION}"
            exit 1
          fi

          # Verify package name matches
          API_NAME=$(echo "$API_RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin)['info']['name'])" 2>/dev/null || echo "")

          if [ "$API_NAME" != "$PACKAGE_NAME" ]; then
            echo "Error: Package name mismatch. Expected ${PACKAGE_NAME}, got ${API_NAME}"
            exit 1
          fi

          echo "✓ Package verified on PyPI API"
          echo "✓ Version matches: ${VERSION}"
          echo "✓ Package name matches: ${PACKAGE_NAME}"
          echo ""
          echo "Package published successfully!"
          echo "View on PyPI: https://pypi.org/project/${PACKAGE_NAME}/${VERSION}/"
          echo ""
          echo "Install with: pip install ${PACKAGE_NAME}==${VERSION}"
