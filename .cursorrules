# Cursor Rules for AudioMeta Python

## Code Style and Comments

### Avoid Unnecessary Comments

Do NOT add comments for functions, classes, or modules that are self-explanatory. The function name, class name, and parameters should clearly indicate what they do.

#### ‚ùå Avoid these unnecessary comments:

```python
"""Test cases for artists metadata."""
class TestArtistsMetadata:
    """Test cases for artists metadata."""

def test_artists_metadata_mp3():
    """Test artists metadata for MP3 files."""

def test_forced_format_affects_delete_metadata_behavior():
    """Test that forced format affects delete_metadata behavior."""

def get_user_name():
    """This function returns the user's name."""
    return user.name

def calculate_total(price, tax):
    """This function calculates the total price."""
    return price + (price * tax)
```

#### ‚úÖ Good - No comments needed:

```python
class TestArtistsMetadata:
    def test_artists_metadata_mp3(self, sample_mp3_file: Path, temp_audio_file: Path):
        # Test implementation here

    def test_forced_format_affects_delete_metadata_behavior(self):
        # Test implementation here

def get_user_name():
    return user.name

def calculate_total(price, tax):
    return price + (price * tax)
```

#### ‚úÖ Only add comments when they provide value:

```python
def calculate_compound_interest(principal, rate, time):
    # Uses the formula: A = P(1 + r/n)^(nt) where n=12 for monthly compounding
    return principal * (1 + rate/12) ** (12 * time)

def process_audio_metadata(file_path):
    # Handles edge cases where ID3v2 tags may be corrupted
    # and falls back to ID3v1 if necessary
    try:
        return extract_id3v2_metadata(file_path)
    except CorruptedTagError:
        return extract_id3v1_metadata(file_path)
```

### When to Add Comments

Only add function, class, or module comments when:

1. The function/class implements complex business logic that isn't obvious
2. There are important edge cases or assumptions to document
3. The function/class has non-obvious side effects
4. The function/class uses algorithms or formulas that need explanation
5. There are performance considerations or limitations to note

### When NOT to Add Comments

Do NOT add comments for:

- Simple getter/setter functions
- Functions with descriptive names that clearly indicate their purpose
- Standard CRUD operations
- Functions that are self-documenting through their implementation
- Test functions with obvious names like `test_artists_metadata_mp3`
- Class docstrings that just repeat the class name
- Module docstrings that just describe what the module contains

## Python Style

### Type Hints

- Use `list`, `dict`, `tuple`, `|` instead of `List`, `Dict`, `Tuple`, `Union`
- Only add type hints when necessary for clarity

### Commit Messages

- Must be concise and descriptive
- Focus on what changed, not how
- Use conventional commit prefixes:
  - `feat:` for new features
  - `fix:` for bug fixes
  - `refactor:` for code refactoring
  - `chore:` for maintenance tasks
  - `chore(test):` for test-related changes (reorganization, new tests, etc.)
  - `docs:` for documentation changes
  - `style:` for formatting changes
  - `perf:` for performance improvements

#### Test-Related Commit Prefixes

Use `fix(test):` for:

- Fixing a bug in a test

Use `test:` for:

- General test update/fix

Use `chore:` for:

- Non-functional maintenance

Use `chore(test):` for:

- Maintenance related to tests (rare)
- Test reorganization or restructuring
- Standardizing test patterns (e.g., using script helpers consistently)
- Adding new test files or test utilities
- Updating test fixtures or test data
- Test maintenance and cleanup

## Test Organization

### Test Types and Markers

Tests are organized into three categories with clear markers:

- **Unit Tests** (`@pytest.mark.unit`): Fast (milliseconds), test individual components in isolation
- **Integration Tests** (`@pytest.mark.integration`): Medium speed (seconds), test component interactions
- **E2E Tests** (`@pytest.mark.e2e`): Slow (minutes), test complete user workflows

### Unit Test Principles

Unit tests should test **individual components in isolation** with fast, focused tests that verify behavior without external dependencies.

#### Unit Test Guidelines:

- Test individual classes and their methods directly
- Fast execution (milliseconds)
- No external tools or services (external tools should be mocked or avoided)
- Focus on behavior, not implementation
- Test error paths specific to the component
- When mocking, exact values from mocks are acceptable for testing controlled scenarios
- **File I/O operations are acceptable** when testing file operations directly (pragmatic approach)

#### Pragmatic Approach to File I/O in Unit Tests

For audio file libraries, file I/O operations are often **part of the functionality being tested**, not external dependencies. This codebase follows a pragmatic approach:

- ‚úÖ **Use real small files** when testing file operations directly (e.g., `read()`, `write()`, `get_duration_in_sec()`)
- ‚úÖ **Use real small files** when the operation inherently requires file access (e.g., metadata reading/writing)
- ‚ùå **Mock or avoid** external tools (e.g., `ffmpeg`, `mid3v2`, `vorbiscomment`)
- ‚ùå **Mock or avoid** network calls, databases, or other external services

#### ‚úÖ Good Unit Test Examples:

```python
# ‚úÖ Test AudioFile class methods directly with real files
def test_get_duration_in_sec_mp3(self, sample_mp3_file: Path):
    audio_file = AudioFile(sample_mp3_file)
    duration = audio_file.get_duration_in_sec()
    assert isinstance(duration, float)
    assert duration > 0

# ‚úÖ Test file I/O operations with real files (pragmatic approach)
def test_file_operations(self):
    with TempFileWithMetadata({}, "mp3") as test_file:
        audio_file = AudioFile(test_file.path)
        test_data = b"test audio data"
        bytes_written = audio_file.write(test_data)
        assert bytes_written == len(test_data)
        read_data = audio_file.read()
        assert read_data == test_data

# ‚úÖ Test error handling for this component
def test_get_duration_in_sec_nonexistent_file(self):
    with pytest.raises(FileNotFoundError):
        AudioFile("nonexistent.mp3").get_duration_in_sec()
```

#### ‚ùå Bad Unit Test Examples:

```python
# ‚ùå Don't use external tools in unit tests
def test_get_duration_in_sec_mp3(self, sample_mp3_file: Path):
    external_duration = TechnicalInfoInspector.get_duration(sample_mp3_file)
    duration = AudioFile(sample_mp3_file).get_duration_in_sec()
    assert duration == external_duration
# Don't verify exact values with external tools - that's for integration tests

# ‚ùå Don't test through wrappers in unit tests
def test_get_duration_in_sec(self, sample_mp3_file: Path):
    duration = get_duration_in_sec(sample_mp3_file)  # Top-level function
    assert duration > 0
# Test AudioFile methods directly, not wrapper functions
```

### Integration Test Principles

Integration tests should verify **component interactions**, not duplicate unit tests.

#### Integration Test Guidelines:

- Test component interactions
- Verify non-trivial wrapper functions work correctly
- Use external tools for verification
- Test different input types (str, Path, AudioFile)
- Don't duplicate unit test coverage

#### ‚úÖ Good Integration Test Examples:

```python
# ‚úÖ Tests that wrapper correctly handles different input types
def test_get_duration_in_sec_works_with_audio_file_object(self, sample_mp3_file: Path):
    audio_file = AudioFile(sample_mp3_file)
    duration = get_duration_in_sec(audio_file)  # Passing AudioFile directly
    assert duration > 0

# ‚úÖ Tests external tool verification
def test_get_duration_in_sec_matches_external_tool(self, sample_mp3_file: Path):
    external_duration = TechnicalInfoInspector.get_duration(sample_mp3_file)
    duration = get_duration_in_sec(sample_mp3_file)
    assert duration == pytest.approx(external_duration)
```

#### ‚ùå Bad Integration Test Examples:

```python
# ‚ùå Just testing AudioFile again through wrapper
def test_get_duration_in_sec_unsupported_file_type_raises_error(self):
    with pytest.raises(FileTypeNotSupportedError):
        get_duration_in_sec("file.txt")
# This is already tested in unit tests for AudioFile
```

### E2E Test Principles

End-to-end tests should verify **complete user workflows** from start to finish, simulating real-world usage scenarios.

#### E2E Test Guidelines:

- Test complete user scenarios
- Simulate real-world usage
- Test the full stack (CLI, API, file operations)
- Focus on workflows, not individual functions
- May be slower but provide confidence in system behavior
- Test happy paths and critical user journeys

#### ‚úÖ Good E2E Test Examples:

```python
# ‚úÖ Test complete user workflow
def test_complete_metadata_editing_workflow(temp_audio_file: Path):
    # User reads metadata
    metadata = get_unified_metadata(temp_audio_file)
    assert metadata.get(UnifiedMetadataKey.TITLE) is None

    # User writes metadata
    update_metadata(temp_audio_file, {
        UnifiedMetadataKey.TITLE: "New Title",
        UnifiedMetadataKey.ARTISTS: ["New Artist"]
    })

    # User reads back to verify
    updated_metadata = get_unified_metadata(temp_audio_file)
    assert updated_metadata.get(UnifiedMetadataKey.TITLE) == ["New Title"]
    assert updated_metadata.get(UnifiedMetadataKey.ARTISTS) == ["New Artist"]
```

#### ‚ùå Bad E2E Test Examples:

```python
# ‚ùå Testing individual components
def test_audio_file_class_in_e2e(temp_audio_file: Path):
    audio_file = AudioFile(temp_audio_file)
    duration = audio_file.get_duration_in_sec()
    assert duration > 0
# This is a unit test concern
```

### Test Naming

- Test function names should be descriptive enough that comments are unnecessary
- Use `test_` prefix followed by what is being tested
- Include the format being tested when relevant (e.g., `test_artists_metadata_mp3`)

### Test Structure

- Group related tests in classes
- Use descriptive class names that don't need docstrings
- Focus on testing behavior, not implementation details

### Test Data Strategy

The test suite uses a **hybrid approach** for test data management, combining pre-created files with on-the-fly generation.

#### Pre-created Test Files (`../assets/`)

**Use pre-created files for:**

- Reading existing metadata from files with known metadata
- Edge cases: Corrupted files, bad extensions, unusual filenames
- Metadata combinations: Files with specific metadata formats and values
- Performance scenarios: Different bitrates, durations, and file sizes
- Regression tests: Known problematic files that previously caused issues
- Format validation: Files with multiple metadata formats in the same file

**Benefits:**

- ‚ö° Fast: Instant access, no script execution overhead
- üéØ Reliable: Pre-tested and known to work correctly
- üìä Comprehensive: Covers complex scenarios that would be difficult to generate
- üîÑ Stable: Consistent across test runs

**Example:**

```python
def test_read_metadata_from_pre_created_file(sample_mp3_file: Path):
    metadata = get_unified_metadata(sample_mp3_file)
    assert metadata.get(UnifiedMetadataKey.TITLE) == ["Sample Title"]
```

#### On-the-fly Generation (TempFileWithMetadata)

**Use TempFileWithMetadata for:**

- **Writing tests**: When testing the application's metadata writing functionality
- **Setup for reading/deleting tests**: When you need initial metadata setup before testing reading or deletion
- Dynamic scenarios: Specific metadata combinations not available in pre-created files
- Clean state: Fresh files for each test run
- Isolation: Prevents test setup from depending on the code being tested

**When setting up metadata in tests, use helper classes:**

- All metadata setup operations in tests must use helper classes from `audiometa.test.helpers` (e.g., `ID3v2MetadataSetter`, `RIFFMetadataSetter`) - not subprocess or external tools directly
- Always use context managers (`TempFileWithMetadata`) for temporary files
- Access file path via `test_file.path` property

**Example:**

```python
def test_write_metadata_using_temp_file():
    with TempFileWithMetadata(
        {"title": "Original Title", "artist": "Original Artist"},
        "mp3"
    ) as test_file:
        update_metadata(test_file.path, {
            UnifiedMetadataKey.TITLE: "New Title"
        })
        metadata = get_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.TITLE) == ["New Title"]
```

#### ‚ùå Avoid using shutil for test files:

```python
def test_wav_sync_multiple_values(self, sample_wav_file: Path, temp_audio_file: Path):
    test_file = temp_audio_file.with_suffix('.wav')
    shutil.copy2(sample_wav_file, test_file)  # Don't do this
```

#### ‚ùå WRONG - Don't use subprocess or external tools directly for metadata setup:

```python
def test_metadata_writing(self):
    with TempFileWithMetadata({}, "mp3") as test_file:
        # ‚ùå NEVER use subprocess or external tools directly for metadata setup
        import subprocess
        subprocess.run([
            "mid3v2",
            "--song=Test Title",
            "--artist=Test Artist",
            str(test_file.path)
        ], check=True)
```

#### ‚úÖ CORRECT - Use helper classes for metadata setup:

```python
def test_metadata_writing(self):
    from audiometa.test.helpers.id3v2 import ID3v2MetadataSetter

    with TempFileWithMetadata({}, "mp3") as test_file:
        # ‚úÖ Use helper classes for metadata setup
        ID3v2MetadataSetter.set_title(test_file.path, "Test Title")
        ID3v2MetadataSetter.set_artists(test_file.path, "Test Artist")

        # Test reading...
```

### Test Isolation and Avoiding Circular Dependencies

#### All Tests Must Use External Tools for Initial Data Setup

For tests that verify **reading, writing, or deleting functionality**, NEVER use the library's own `update_metadata()` function to set up initial test data. This ensures proper test isolation and prevents testing the library's own writing logic when testing other functionality.

#### ‚ùå WRONG - Poor test isolation:

```python
def test_id3v1_genre_reading(self):
    with TempFileWithMetadata({"title": "Test Song"}, "mp3") as test_file:
        # ‚ùå Using our own library to set metadata - poor test isolation
        update_metadata(test_file.path, {
            UnifiedMetadataKey.GENRES_NAMES: ["Rock"]
        }, metadata_format=MetadataFormat.ID3V1)

        # Testing reading - but we used our own writing logic!
        metadata = get_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRES_NAMES) == ["Rock"]

def test_delete_lyrics_id3v2(self):
    with TempFileWithMetadata({}, "mp3") as test_file:
        # ‚ùå Using our own library to set initial data - poor test isolation
        update_metadata(test_file.path, {UnifiedMetadataKey.UNSYNCHRONIZED_LYRICS: "Test lyrics"})

        # Testing deletion - but we used our own writing logic to set up!
        update_metadata(test_file.path, {UnifiedMetadataKey.UNSYNCHRONIZED_LYRICS: None})
        assert get_unified_metadata_field(test_file.path, UnifiedMetadataKey.UNSYNCHRONIZED_LYRICS) is None
```

#### ‚úÖ CORRECT - Use external tools for proper test isolation:

```python
def test_id3v1_genre_reading(self):
    from audiometa.test.helpers.id3v1 import ID3v1MetadataSetter

    with TempFileWithMetadata({"title": "Test Song"}, "mp3") as test_file:
        # ‚úÖ Use helper class to set metadata - proper test isolation
        ID3v1MetadataSetter.set_metadata(test_file.path, {"genre": "Blues"})

        # Now test reading with external verification
        metadata = get_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRES_NAMES) == ["Blues"]

def test_delete_lyrics_id3v2(self):
    from audiometa.test.helpers.id3v2 import ID3v2MetadataSetter

    with TempFileWithMetadata({}, "mp3") as test_file:
        # ‚úÖ Use helper class to set initial data - proper test isolation
        ID3v2MetadataSetter.set_metadata(test_file.path, {"lyrics": "Test lyrics"})

        # Test deletion using our library
        update_metadata(test_file.path, {UnifiedMetadataKey.UNSYNCHRONIZED_LYRICS: None})
        assert get_unified_metadata_field(test_file.path, UnifiedMetadataKey.UNSYNCHRONIZED_LYRICS) is None
```

#### ‚úÖ ALTERNATIVE - Use TempFileWithMetadata with specific format:

```python
def test_id3v1_genre_reading(self):
    # ‚úÖ TempFileWithMetadata uses external tools internally
    with TempFileWithMetadata({"genre": "Rock"}, "id3v1") as test_file:
        metadata = get_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRES_NAMES) == ["Rock"]
```

#### Available Helper Classes

Use helper classes from `audiometa.test.helpers` for metadata setup:

- **ID3v2**: `ID3v2MetadataSetter` - `set_title()`, `set_artists()`, `set_metadata()`, `set_comment()`, etc.
- **ID3v1**: `ID3v1MetadataSetter` - `set_title()`, `set_artists()`, `set_comment()`, `set_metadata()`, etc.
- **Vorbis**: `VorbisMetadataSetter` - `set_title()`, `set_artists()`, `set_comment()`, `set_metadata()`, etc.
- **RIFF**: `RIFFMetadataSetter` - `set_title()`, `set_comment()`, `set_metadata()`, etc.

**Note**: Helper classes use external tools internally for proper test isolation.

#### When to Use Each Approach

- **Reading tests**: Use helper classes (`ID3v2MetadataSetter`, etc.) for initial data setup
- **Writing tests**: Use helper classes for initial data setup, then test `update_metadata()` functionality
- **Deleting tests**: Use helper classes for initial data setup, then test deletion using library API (`update_metadata()` with `None` values)
- **Integration tests**: Use helper classes consistently for metadata setup
- **Unit tests**: Use mocks and direct object instantiation (file I/O is acceptable when testing file operations directly)

### Test Data Strategy

The test suite uses a **hybrid approach** for test data management:

#### Pre-created Test Files (`../assets/`)

**Use pre-created files for:**

- Edge cases: Corrupted files, bad extensions, unusual filenames
- Metadata combinations: Files with specific metadata formats and values
- Performance scenarios: Different bitrates, durations, and file sizes
- Regression tests: Known problematic files that previously caused issues
- Format validation: Files with multiple metadata formats in the same file

**Benefits:**

- ‚ö° Fast: Instant access, no script execution overhead
- üéØ Reliable: Pre-tested and known to work correctly
- üìä Comprehensive: Covers complex scenarios that would be difficult to generate
- üîÑ Stable: Consistent across test runs

**Example:**

```python
def test_read_metadata_from_pre_created_file(sample_mp3_file: Path):
    metadata = get_unified_metadata(sample_mp3_file)
    assert metadata.get(UnifiedMetadataKey.TITLE) == ["Sample Title"]
```

#### On-the-fly Generation (TempFileWithMetadata)

**Use TempFileWithMetadata for:**

- Writing tests: When testing the application's metadata writing functionality
- Dynamic scenarios: Specific metadata combinations not available in pre-created files
- Clean state: Fresh files for each test run
- Isolation: Prevents test setup from depending on the code being tested

**Example:**

```python
def test_write_metadata_using_temp_file():
    with TempFileWithMetadata(
        {"title": "Original Title", "artist": "Original Artist"},
        "mp3"
    ) as test_file:
        update_metadata(test_file.path, {
            UnifiedMetadataKey.TITLE: "New Title"
        })
        metadata = get_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.TITLE) == ["New Title"]
```

#### Test Principle: Only Test the API Function Being Tested

**The rule**: In any test, only use the API function that you're actually testing. Everything else should use helper methods.

**‚úÖ CORRECT - Deletion tests:**

```python
def test_delete_comment_riff(self):
    from audiometa.test.helpers.riff import RIFFMetadataSetter

    with TempFileWithMetadata({}, "wav") as test_file:
        # ‚úÖ Use helper class for setup - not testing setup functionality
        RIFFMetadataSetter.set_comment(test_file.path, "Test comment")
        assert get_unified_metadata_field(test_file.path, UnifiedMetadataKey.COMMENT) == "Test comment"

        # ‚úÖ Test deletion using library API - this is what we're testing
        update_metadata(test_file.path, {UnifiedMetadataKey.COMMENT: None}, metadata_format=MetadataFormat.RIFF)
        assert get_unified_metadata_field(test_file.path, UnifiedMetadataKey.COMMENT) is None
```

**‚úÖ CORRECT - Reading tests:**

```python
def test_read_comment_riff(self):
    from audiometa.test.helpers.riff import RIFFMetadataSetter

    with TempFileWithMetadata({}, "wav") as test_file:
        # ‚úÖ Use helper class for setup - not testing setup functionality
        RIFFMetadataSetter.set_comment(test_file.path, "Test comment")

        # ‚úÖ Test reading using library API - this is what we're testing
        comment = get_unified_metadata_field(test_file.path, UnifiedMetadataKey.COMMENT)
        assert comment == "Test comment"
```

**‚úÖ CORRECT - Writing tests:**

```python
def test_write_comment_riff(self):
    with TempFileWithMetadata({}, "wav") as test_file:
        # ‚úÖ Test writing using library API - this is what we're testing
        update_metadata(test_file.path, {UnifiedMetadataKey.COMMENT: "Test comment"}, metadata_format=MetadataFormat.RIFF)

        # ‚úÖ Use helper method for verification - not testing reading functionality
        comment = get_unified_metadata_field(test_file.path, UnifiedMetadataKey.COMMENT)
        assert comment == "Test comment"
```

#### ‚ùå WRONG - Don't mix API functions in tests:

```python
def test_delete_comment_riff(self):
    with TempFileWithMetadata({}, "wav") as test_file:
        # ‚ùå Using library API for setup when testing deletion
        update_metadata(test_file.path, {UnifiedMetadataKey.COMMENT: "Test comment"}, metadata_format=MetadataFormat.RIFF)

        # ‚úÖ This is correct - testing deletion
        update_metadata(test_file.path, {UnifiedMetadataKey.COMMENT: None}, metadata_format=MetadataFormat.RIFF)
        assert get_unified_metadata_field(test_file.path, UnifiedMetadataKey.COMMENT) is None
```

### Individual Metadata Reading Tests

#### Use get_unified_metadata_field for Single Metadata Field Tests

When testing reading of a **single metadata field**, use `get_unified_metadata_field()` instead of `get_unified_metadata()` for better performance and clarity.

#### ‚ùå WRONG - Inefficient for single field:

```python
def test_title_reading(self, test_file):
    metadata = get_unified_metadata(test_file.path)
    title = metadata.get(UnifiedMetadataKey.TITLE)
    assert title == "Expected Title"
```

#### ‚úÖ CORRECT - Use get_unified_metadata_field:

```python
def test_title_reading(self, test_file):
    title = get_unified_metadata_field(test_file.path, UnifiedMetadataKey.TITLE)
    assert title == "Expected Title"
```

#### When to Use Each Function

- **`get_unified_metadata_field()`**: When testing a single metadata field
- **`get_unified_metadata()`**: When testing multiple metadata fields or full metadata workflows

## File Organization

### Module Structure

- Keep related functionality together
- Use clear, descriptive file names
- Avoid unnecessary module docstrings that just describe the file contents

### Import Organization

- Group imports logically
- Use absolute imports when possible
- Keep imports clean and minimal

## Git and Version Control

### Commit Behavior

- **NEVER commit changes automatically**
- Always ask the user before making any git commits
- Let the user review changes before committing
- Only suggest commit messages, don't execute commits without explicit user approval
